---
title: "subjective_analysis"
output: html_document
date: "2025-04-03"
---

```{r}
library(tidyverse)

# Load and clean data
df <- read_csv("C:\\Users\\SREAL\\Lab Users\\mattg\\research\\projects\\world-switch-ui\\experiment\\data\\questionnaires\\ranking_drop.csv")

interface_labels <- c(
  "Interface_1" = "Baseline",
  "Interface_2" = "Portal Gallery",
  "Interface_3" = "Portal Palette Hand",
  "Interface_4" = "Portal Palette Head",
  "Interface_5" = "Portal Steering wheel",
  "Interface_6" = "WIM Gallery",
  "Interface_7" = "WIM Palette Hand",
  "Interface_8" = "WIM Palette Head",
  "Interface_9" = "WIM Steering wheel"
)

# Keep only the first 10 columns (PID + 9 interfaces)
ranking_count = read_csv("C:\\Users\\SREAL\\Lab Users\\mattg\\research\\projects\\world-switch-ui\\experiment\\data\\questionnaires\\Interface_Ranking_Counts.csv")

# Perform the chi-square test
chi_square_result <- chisq.test(ranking_count)

# Print the results
print(chi_square_result)

counts <- read.csv("C:\\Users\\SREAL\\Lab Users\\mattg\\research\\projects\\world-switch-ui\\experiment\\data\\questionnaires\\Interface_Ranking_Counts.csv", row.names = 1)
counts_matrix <- as.matrix(counts)
chisq.test(counts_matrix)


# Convert to long format
df_long <- df %>%
  pivot_longer(cols = starts_with("Rank_"),
               names_to = "Interface",
               values_to = "Rank") %>%
  mutate(Rank = as.numeric(Rank))

# Compute average rank for ordering
avg_ranks <- df_long %>%
  group_by(Interface) %>%
  summarise(AverageRank = mean(Rank, na.rm = TRUE) * -1) %>%
  arrange(AverageRank)

# Prepare data for plotting
plot_data <- df_long %>%
  count(Interface, Rank) %>%
  group_by(Interface) %>%
  mutate(Proportion = n / sum(n)) %>%
  ungroup() %>%
  mutate(Interface = factor(Interface, levels = avg_ranks$Interface)) %>% # reorder
  group_by(Interface) %>%
  arrange(Rank) %>%
  mutate(Interface = recode(Interface, !!!interface_labels)) %>%
  mutate(pos = 1 - (cumsum(Proportion) - Proportion / 2))  # position for label


textsize = 20
titlesize = 20

# rename interface on y-axis

# Plot
rankplot = ggplot(plot_data, aes(x = Proportion, y = Interface, fill = factor(Rank))) +
  geom_col(width = 0.8) +
  scale_x_reverse(labels = scales::percent_format(accuracy = 1)) +
  geom_text(aes(label = scales::percent(Proportion, accuracy = 1, suffix = ""), x = pos),
          color = ifelse(plot_data$Rank %in% 1:3, "black", ifelse(plot_data$Rank %in% 4:6, "white", "#ff98aa")), 
          size = 5, fontface = "bold") +
  scale_fill_viridis_d(name = "Rank", direction = -1) +
  labs(title = "Ranks per Interface (Sorted by Average Rank)",
       x = "Percentage of Participants", y = "Interface") +
  # scale_y_discrete(labels = c("B", "P–G",  "P–HaP", "P–HeP", "P–WW", "W–G", "W–HaP", "W–HeP", "W–WW")) +
  scale_y_discrete(labels = c("Baseline", "Portal Gallery", "Portal Palette Hand", "Portal Palette Head", "Portal World Wheel", "WIM Gallery", "WIM Palette Hand", "WIM Palette Head", "WIM World Wheel")) +
  theme_minimal() +
  guides(fill = guide_legend(nrow = 1)) +
  theme(legend.position = "top",
        legend.direction = "horizontal",
        # legend.box = "horizontal",
        legend.text = element_text(size = textsize),
        legend.title = element_text(size = titlesize),
        legend.key.width = unit(1, "cm"), # Adjust width to fit in one line
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.y = element_text(size = textsize, 
                        margin = margin(t = 0, b = 0)),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_blank())

rankplot
                        # Save the plot as a PDF
ggsave("C:\\Users\\SREAL\\Lab Users\\mattg\\research\\projects\\world-switch-ui\\experiment\\data\\analysis\\charts\\chi25\\ranking_bar_2.pdf", plot = rankplot, width = 12, height = 5, dpi = 300)
```

Questionnaire Results
```{r}
# Load CSV
df = read.csv("C:\\Users\\SREAL\\Lab Users\\mattg\\research\\projects\\world-switch-ui\\experiment\\data\\analysis\\subjective_corrected_inv.csv")

df$Interface_Choice <- as.factor(df$Interface_Choice)
df$Remembered_Choice <- as.factor(df$Remembered_Choice)
df$PID <- as.factor(df$PID)

df$Interface_Choice <- recode(df$Interface_Choice,
  "Baseline - static menu with ray-based selection" = "Baseline",
  "Portal - head-reference with linear menu" = "Portal Gallery",
  "Portal - Palette with hand-based selections" = "Portal Palette Hand",
  "Portal - Palette with head-based selections" = "Portal Palette Head",
  "Portal - Steering Wheel" = "Portal Steering Wheel",
  "WIM - head-referenced with linear menu" = "WIM Gallery",
  "WIM - Palette with hand-based selections" = "WIM Palette Hand",
  "WIM - Palette with head-based selections" = "WIM Palette Head",
  "WIM Steering Wheel" = "WIM Steering Wheel"
)

demographics_df = read.csv("C:\\Users\\SREAL\\Lab Users\\mattg\\research\\world-switch-ui\\experiment\\data\\questionnaires\\demographics.csv")
demographics_df$PID = as.factor(demographics_df$ParticipantID)
demographics_df$Age = as.numeric(demographics_df$Age)
demographics_df$Sex = as.factor(demographics_df$Sex)
demographics_df$VR_Exp = as.factor(demographics_df$VR_Exp)
print(demographics_df)
# left join demographics data 
df <- left_join(df, demographics_df, by = "PID")

# filter out PID 13
df <- df %>% filter(PID != 13)

library(dplyr)
library(tibble)

# Technique metadata (excluding TechniqueCount)
technique_meta <- tribble(
  ~Interface_Choice, ~Preview, ~InteractionSpace, ~PreviewSpace, ~InteractionMetaphor,
  "WIM_SteeringWheel", "WIM", "Bimanual", "Bimanual", "SteeringWheel",
  "WIM_Gallery", "WIM", "OneHanded", "Head", "Gallery",
  "WIM_Palette_HeadHand", "WIM", "HeadHand", "Hand", "Palette_Head",
  "WIM_Palette_Hand", "WIM", "Bimanual", "Hand", "Palette_Hand",
  "Baseline", "None", "OneHanded", "World", "Baseline",
  "Portal_SteeringWheel", "Portal", "Bimanual", "Bimanual", "SteeringWheel",
  "Portal_Gallery", "Portal", "OneHanded", "Head", "Gallery",
  "Portal_Palette_HeadHand", "Portal", "HeadHand", "Hand", "Palette_Head",
  "Portal_Palette_Hand", "Portal", "Bimanual", "Hand", "Palette_Hand"
)

# Check that Interface_Choice column exists
if (!"Interface_Choice" %in% names(df)) {
  stop("The dataframe must have a column named 'Interface_Choice'")
}

# Identify missing techniques
existing_choices <- unique(df$Interface_Choice)
missing_choices <- setdiff(technique_meta$Interface_Choice, existing_choices)

# Create new rows for missing techniques
rows_to_add <- technique_meta %>%
  filter(Interface_Choice %in% missing_choices)

# Combine original and added rows
df_extended <- bind_rows(df, rows_to_add)

# Join metadata to all rows
df_final <- df_extended %>%
  left_join(technique_meta, by = "Interface_Choice")


# Convert TLX items to long format
df_long <- df %>%
  pivot_longer(cols = starts_with("TLX"), names_to = "TLX_Item", values_to = "Score") %>%
  mutate(TLX_Item = recode(TLX_Item,
                           "TLX_1_1" = "tlx_mental",
                           "TLX_2_1" = "tlx_physical",
                           "TLX_3_1" = "tlx_temporal",
                           "TLX_4_1" = "tlx_perf",
                           "TLX_5_1" = "tlx_effort",
                           "TLX_6_1" = "tlx_frustration"))

# Create boxplots for each TLX question, grouped by Interface_Choice
tlx_everyQ = ggplot(df_long, aes(x = Interface_Choice, y = Score, fill = Interface_Choice)) +
  geom_boxplot() +
  facet_wrap(~ TLX_Item, scales = "free_y") +
  theme_minimal() +
  labs(title = "Boxplots of TLX Scores by Technique", x = "Interface Choice", y = "Score") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")

tlx_everyQ

# Compute average TLX score
tlx_cols <- grep("^TLX_\\d+_1$", names(df), value = TRUE)
print(tlx_cols)
df$tlx_all = rowMeans(df[tlx_cols], na.rm = TRUE)
# df <- df %>%
#   mutate(TLX_All = rowMeans(select(., starts_with("TLX_")), na.rm = TRUE))

# Boxplot of overall TLX scores by interface
tlx_overall = ggplot(df, aes(x = Interface_Choice, y = tlx_all, fill = Interface_Choice)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Overall TLX Score by Interface", x = "Interface Choice", y = "Average TLX Score") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position  = "none")
tlx_overall

# Identify SUS columns
sus_cols <- grep("^SUS_\\d+_1$", names(df), value = TRUE)
print(sus_cols)

# Calculate SUS total score (commonly scaled to 0–100)
df$sus_score <- rowSums(df[sus_cols]) * 2.5  # 10 items * 2.5 = 100 max

# Boxplot of SUS scores across all participants
sus = ggplot(df, aes(x = Interface_Choice, y = sus_score, fill = Interface_Choice)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "SUS Scores by Interface", x = "Interface Choice", y = "SUS Score (0–100)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")
sus

#####################
# UEQ

# Get all UEQ columns (assuming UEQ_1_1 to UEQ_1_8 style)
ueq_cols <- grep("^UEQ_\\d+_\\d+(\\.\\d+)?$", names(df), value = TRUE)

# Sort and split columns
ueq_first4 <- ueq_cols[1:4]
ueq_last4  <- ueq_cols[5:8]

# Compute averages
df <- df %>%
  mutate(
    UEQ_Practical = rowMeans(across(all_of(ueq_first4)), na.rm = TRUE),
    UEQ_Hedonic   = rowMeans(across(all_of(ueq_last4)), na.rm = TRUE),
    UEQ_Overall   = rowMeans(across(all_of(ueq_cols)), na.rm = TRUE)
  )

# Pivot to long format for plotting
df_ueq_long <- df %>%
  select(Interface_Choice, UEQ_Practical, UEQ_Hedonic, UEQ_Overall) %>%
  pivot_longer(cols = starts_with("UEQ"), names_to = "UEQ_Type", values_to = "Score")

# Create box plots
ueq_all = ggplot(df_ueq_long, aes(x = Interface_Choice, y = Score, fill = Interface_Choice)) +
  geom_boxplot() +
  facet_wrap(~ UEQ_Type) +
  theme_minimal() +
  labs(title = "UEQ Scores by Interface", x = "Interface Choice", y = "Score") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")

ueq_all

# just hedonic category of the UEQ
ueq_hedonic = ggplot(df, aes(x = Interface_Choice, y = UEQ_Hedonic, fill = Interface_Choice)) +
  geom_boxplot() +
  theme_minimal() +
  labs(title = "Hedonic UEQ Scores by Interface", x = "Interface Choice", y = "Score") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "none")
ueq_hedonic

# get Cont columns
cont_cols <- grep("^Cont_\\d+_1$", names(df), value = TRUE)
df$cont_avg = rowMeans(df[cont_cols], na.rm = TRUE)

```

```{r}

numeric_vars <- names(df)[sapply(df, is.numeric)]
numeric_vars
# Normalize the UEQ_Hedonic column
df_nrml_subjective <- datawizard::normalize(df, select = numeric_vars, include_bounds = FALSE)

df_org_subjective = df
df = df_nrml_subjective
glm_ctrl = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1000000000))
```

UEQ Hedonic Results
```{r}
df = df_nrml_subjective
# check distribution of the data
hist(df$UEQ_Hedonic, breaks = 20, main = "Histogram of UEQ Hedonic Scores", xlab = "UEQ Hedonic Score", ylab = "Frequency")

# density plot
plot(density(df$UEQ_Hedonic, na.rm = TRUE), main = "Density Plot of UEQ Hedonic Scores", xlab = "UEQ Hedonic Score", ylab = "Density")

shapiro.test(df$UEQ_Hedonic) # Shapiro-Wilk normality test
qqnorm(df$UEQ_Hedonic) # Q-Q plot
qqline(df$UEQ_Hedonic, col = "red") # Q-Q line

ueq_linear = lmerTest::lmer(UEQ_Hedonic ~ Interface_Choice + (1 | PID),
                 data = df)

ueqH_gaussian = glmer(UEQ_Hedonic ~ Interface_Choice + (1 | PID),
                 data = df,
                 family = gaussian(link = "log"),
                 control = glm_ctrl)

ueqH_gaussian2 = glmer(UEQ_Hedonic ~ Interface_Choice + VR_Exp + (1 | PID),
                 data = df,
                 family = gaussian(link = "log"),
                 control = glm_ctrl)

Cand.mods = list(
          "ueqH_gaussian" = ueqH_gaussian,
          "ueqH_gaussian2" = ueqH_gaussian2
           )

# glm_1_4 is ranked best for AICc and BIC
# including trial and technique preview as random slope leads to convergence issues

AICcmodavg::aictab(cand.set = Cand.mods)
AICcmodavg::bictab(cand.set = Cand.mods)

# Check for normality of residuals
shapiro.test(residuals(ueqH_gaussian)) # Shapiro-Wilk normality test

glm = ueq_linear
performance::check_model(glm)
performance::check_collinearity(glm)
performance::check_singularity(glm)
performance::check_outliers(glm)
performance::r2(glm)
simulationOutput <- simulateResiduals(fittedModel = glm)
testDispersion(simulationOutput)
car::Anova(glm)
summary(glm)
# Perform pairwise comparisons with Tukey HSD correction
emm_ueq <- emmeans::emmeans(glm, specs = pairwise ~ Interface_Choice, type = "response", adjust = "tukey")
emm_ueq

subj_ast_spacing = 0.1

plot_ueq <- function(data) {

  box = ggplot(data, aes(x = Interface_Choice, y = UEQ_Hedonic, fill = Interface_Choice)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Set3") +  # colorblind-safe palette
    scale_y_continuous(breaks = seq(0, 7, by = 1),  # Add ticks for every 5 units, including 40
                       minor_breaks = seq(0, 7, by = 0.5),
                       limits = c(1, 10.25)) +    # Label all ticks
    # scale_x_discrete(labels = c("Baseline", "Portal Gallery",  "Portal Palette Hand", "Portal Palette Head", "Portal Steering Wheel", "WIM Gallery", "WIM Palette Hand", "WIM Palette Head", "WIM Steering Wheel")) +  # Update x-axis labels
    scale_x_discrete(labels = c("B", "P–G",  "P–HaP", "P–HeP", "P–WW", "W–G", "W–HaP", "W–HeP", "W–WW")) +
    labs(
      x = "Interaction Technique",  # Update x-axis title
      y = "Average UEQ Hedonic Score"  # Update y-axis title
    ) +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = textsize),  # Center x-axis labels
      axis.text.y = element_text(size = textsize),  # Added size for y-axis tick marks
      axis.title = element_text(size = titlesize),
      axis.title.x = element_blank(),
      legend.position = "none")
  
  return(box)
}

# Define significance whiskers programmatically
# 1: Baseline
# 2: Portal Gallery
# 3: Portal Palette Hand
# 4: Portal Palette Head
# 5: Portal Steering Wheel
# 6: WIM Gallery
# 7: WIM Palette Hand
# 8: WIM Palette Head
# 9: WIM Steering Wheel
w_h = 0.0 
significance_data_ueq <- data.frame(
    x_start = numeric(),
    x_end = numeric(),
    y_start = numeric(),
    y_end = numeric(),
    label = character()
  )
significance_data_ueq <- significance_data_ueq %>%
  # add horizontal line extending up from baseline
  add_row(x_start = 1, x_end = 1, y_start = 7.5, y_end = 9.25, label = "") %>%
  # add three periods vertically
  add_row(x_start = 0.75, x_end = 0.75, y_start = 7.8, y_end = y_start, label = "*") %>%
  add_row(x_start = 0.75, x_end = 0.75, y_start = 8.2, y_end = y_start, label = "*") %>%
  add_row(x_start = 0.75, x_end = 0.75, y_start = 8.6, y_end = y_start, label = "*") %>%
  # Baseline / Portal Gallery
  add_row(x_start = 1, x_end = 2, y_start = 7.5, y_end = y_start-w_h, label = "") %>%
  # Baseline / Portal Palette Hand
  add_row(x_start = 1, x_end = 3, y_start = 7.75, y_end = y_start-w_h, label = "") %>%
  # Baseline / Portal Palette Head
  add_row(x_start = 1, x_end = 4, y_start = 8, y_end = y_start-w_h, label = "") %>%
  # Baseline / Portal Steering Wheel
  add_row(x_start = 1, x_end = 5, y_start = 8.25, y_end = y_start-w_h, label = "") %>%
  # Baseline / WIM Gallery
  add_row(x_start = 1, x_end = 6, y_start = 8.5, y_end = y_start-w_h, label = "") %>%
  # Baseline / WIM Palette Hand
  add_row(x_start = 1, x_end = 7, y_start = 8.75, y_end = y_start-w_h, label = "") %>%
  # Baseline / WIM Palette Head
  add_row(x_start = 1, x_end = 8, y_start = 9, y_end = y_start-w_h, label = "") %>%
  # Baseline / WIM Steering Wheel
  add_row(x_start = 1, x_end = 9, y_start = 9.25, y_end = y_start-w_h, label = "") %>%
  # Portal Palette Head / WIM Steering Wheel
  add_row(x_start = 4, x_end = 9, y_start = 7.5, y_end = y_start-w_h, label = "*")

# Create the box plot for search time
ueq_plot = plot_ueq(df_org_subjective)
ueq_plot = add_whiskers_periods(ueq_plot, significance_data_ueq, subj_ast_spacing)
ueq_plot
ggsave(file.path(save_base_path, "box_ueq_technique.pdf"), plot = ueq_plot, width = 5, height = 10, dpi = 300)

```

TLX Results
```{r}

# check distribution of the data
hist(df_org_subjective$tlx_all, breaks = 20, main = "Histogram of TLX Scores", xlab = "TLX", ylab = "Frequency")

# density plot
plot(density(df$tlx_all, na.rm = TRUE), main = "Density Plot of UEQ Hedonic Scores", xlab = "UEQ Hedonic Score", ylab = "Density")

shapiro.test(df$UEQ_Hedonic) # Shapiro-Wilk normality test
qqnorm(df$UEQ_Hedonic) # Q-Q plot
qqline(df$UEQ_Hedonic, col = "red") # Q-Q line

df_org_subjective = df
df = df_nrml_subjective
glm_ctrl = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1000000000))

library(lmerTest)
tlx_gaussian = lmerTest::lmer(tlx_all ~ Interface_Choice + (1 | PID),
                 data = df)

tlx_gaussian2 = glmer(tlx_all ~ Interface_Choice + VR_Exp + (1 | PID),
                 data = df,
                 family = gaussian(link = "identity"),
                 control = glm_ctrl)

tlx_gaussian3 = glmer(tlx_all ~ Interface_Choice  + (1 | PID),
                 data = df,
                 family = gaussian(link = "log"),
                 control = glm_ctrl)

Cand.mods = list(
          "tlx_gaussian" = tlx_gaussian,
          "tlx_gaussian2" = tlx_gaussian2
           )

# glm_1_4 is ranked best for AICc and BIC
# including trial and technique preview as random slope leads to convergence issues

AICcmodavg::aictab(cand.set = Cand.mods)
AICcmodavg::bictab(cand.set = Cand.mods)

# Check for normality of residuals

glm = tlx_gaussian
shapiro.test(residuals(glm)) # Shapiro-Wilk normality test
performance::check_model(glm)
performance::check_collinearity(glm)
performance::check_singularity(glm)
performance::check_outliers(glm)
performance::r2(glm)
simulationOutput <- simulateResiduals(fittedModel = glm)
testDispersion(simulationOutput)
car::Anova(glm)
summary(glm)
# Perform pairwise comparisons with Tukey HSD correction
emm_tlx <- emmeans::emmeans(glm, specs = pairwise ~ Interface_Choice, type = "response", adjust = "tukey")
emm_tlx

# Ensure that your response variable is an ordered factor.
# For example, if your variable is 'UEQ_Hedonic' on a 1-7 scale:
df = df_org_subjective
df$TLX_2 <- ordered(df$TLX_2)

# Fit the cumulative link mixed model using the clmm() function.
# Here, 'Interface_Choice' is the fixed effect and 'PID' is the random effect.
clm_q2 <- ordinal::clmm(TLX_2 ~ Interface_Choice + (1 | PID), data = df)
car::Anova(clm_q2)
summary(clm_q2)
emm_tlx2 <- emmeans::emmeans(clm_q2, specs = pairwise ~ Interface_Choice, type = "response", adjust = "tukey")
emm_tlx2

clm_q5 <- ordinal::clmm(TLX_5 ~ Interface_Choice + (1 | PID), data = df)
car::Anova(clm_q5)
summary(clm_q5)
emm_tlx5 <- emmeans::emmeans(clm_q5, specs = pairwise ~ Interface_Choice, type = "response", adjust = "tukey")
emm_tlx5

clm_q6 <- ordinal::clmm(TLX_6 ~ Interface_Choice + (1 | PID), data = df)
car::Anova(clm_q6)
summary(clm_q6)
emm_tlx6 <- emmeans::emmeans(clm_q6, specs = pairwise ~ Interface_Choice, type = "response", adjust = "tukey")
emm_tlx6

# 2: Physical Demand
# 5: Effort
# 6: Frustration
plot_tlx <- function(data) {

  box = ggplot(data, aes(x = Interface_Choice, y = tlx_all, fill = Interface_Choice)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Set3") +  # colorblind-safe palette
    scale_y_continuous(breaks = seq(0, 7, by = 1),  # Add ticks for every 5 units, including 40
                       minor_breaks = seq(0, 7, by = 0.5),
                      limits = c(1, 10.25)) +    # Label all ticks
    # scale_x_discrete(labels = c("Baseline", "Portal Gallery",  "Portal Palette Hand", "Portal Palette Head", "Portal Steering Wheel", "WIM Gallery", "WIM Palette Hand", "WIM Palette Head", "WIM Steering Wheel")) +  # Update x-axis labels
    scale_x_discrete(labels = c("B", "P–G",  "P–HaP", "P–HeP", "P–WW", "W–G", "W–HaP", "W–HeP", "W–WW")) +
    labs(
      x = "Technique",  # Update x-axis title
      y = "Average NASA TLX Score"  # Update y-axis title
    ) +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = textsize),  # Center x-axis labels
      axis.text.y = element_text(size = textsize),  # Added size for y-axis tick marks
      axis.title = element_text(size = titlesize),
      axis.title.x = element_blank(),
      legend.position = "none")

  return(box)
}

significance_data_tlx <- data.frame(
    x_start = numeric(),
    x_end = numeric(),
    y_start = numeric(),
    y_end = numeric(),
    label = character()
  )

  # Define significance whiskers programmatically
  # 1: Baseline
  # 2: Portal Gallery
  # 3: Portal Palette Hand
  # 4: Portal Palette Head
  # 5: Portal Steering Wheel
  # 6: WIM Gallery
  # 7: WIM Palette Hand
  # 8: WIM Palette Head
  # 9: WIM Steering Wheel
  w_h = 0.0
  significance_data_tlx <- significance_data_tlx %>%
    # Baseline / Portal Palette Head
    add_row(x_start = 1, x_end = 4, y_start = 7.5, y_end = y_start-w_h, label = "*") %>%
    # Portal Palette Head / WIM Gallery
    add_row(x_start = 4, x_end = 6, y_start = 8, y_end = y_start-w_h, label = "*") %>%
    # Portal Palette Head / WIM Palette Hand
    add_row(x_start = 4, x_end = 7, y_start = 8.5, y_end = y_start-w_h, label = "***") %>%
    # Portal Palette Head / WIM Steering Wheel
    add_row(x_start = 4, x_end = 9, y_start = 9, y_end = y_start-w_h, label = "***")


# Create the box plot for search time
tlx_plot = plot_tlx(df_org_subjective)
tlx_plot = add_whiskers_periods(tlx_plot, significance_data_tlx, subj_ast_spacing)
tlx_plot
ggsave(file.path(save_base_path, "box_ueq_technique.pdf"), plot = ueq_h, width = 5, height = 10, dpi = 300)

```

SUS Results
```{r}
df = df_nrml_subjective
# check distribution of the data
hist(df$sus_score, breaks = 20, main = "Histogram of UEQ Hedonic Scores", xlab = "UEQ Hedonic Score", ylab = "Frequency")

# density plot
plot(density(df$sus_score, na.rm = TRUE), main = "Density Plot of sus Scores", xlab = "UEQ Hedonic Score", ylab = "Density")

shapiro.test(df$sus_score) # Shapiro-Wilk normality test
qqnorm(df$sus_score) # Q-Q plot
qqline(df$sus_score, col = "red") # Q-Q line

sus_gauss = lmerTest::lmer(sus_score ~ Interface_Choice + (1 | PID),
                 data = df)


# Fit a Beta GLMM
model <- glmmTMB(sus_score ~ Interface_Choice + (1 | PID),
                 data = df_nrml_subjective,
                 family = beta_family(link = "logit"))

sus_gaussian = glmer(sus_score ~ Interface_Choice + (1 | PID),
                 data = df,
                 family = gaussian(link = "log"),
                 control = glm_ctrl)

sus_gaussian2 = glmer(sus_score ~ Interface_Choice + VR_Exp + (1 | PID),
                 data = df,
                 family = gaussian(link = "log"),
                 control = glm_ctrl)

Cand.mods = list(
          "sus_gaussian" = sus_gaussian,
          "sus_gaussian2" = sus_gaussian2
           )

# glm_1_4 is ranked best for AICc and BIC
# including trial and technique preview as random slope leads to convergence issues

AICcmodavg::aictab(cand.set = Cand.mods)
AICcmodavg::bictab(cand.set = Cand.mods)

# Check for normality of residuals

glm = sus_gauss
performance::check_model(glm)
shapiro.test(residuals(glm)) # Shapiro-Wilk normality test
performance::check_collinearity(glm)
performance::check_singularity(glm)
performance::check_outliers(glm)
performance::r2(glm)
simulationOutput <- simulateResiduals(fittedModel = glm)
testDispersion(simulationOutput)
car::Anova(glm)
summary(glm)
# Perform pairwise comparisons with Tukey HSD correction
emm_sus <- emmeans::emmeans(glm, specs = pairwise ~ Interface_Choice, type = "response", adjust = "tukey")
emm_sus


plot_sus <- function(data) {

  box = ggplot(data, aes(x = Interface_Choice, y = sus_score, fill = Interface_Choice)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Set3") +  # colorblind-safe palette
    scale_y_continuous(breaks = seq(0, 100, by = 10),  # Add ticks for every 5 units, including 40
                       minor_breaks = seq(0, 100, by = 5),
                       limits = c(0, 169)) +  # Label all ticks
    # scale_x_discrete(labels = c("Baseline", "Portal Gallery",  "Portal Palette Hand", "Portal Palette Head", "Portal Steering Wheel", "WIM Gallery", "WIM Palette Hand", "WIM Palette Head", "WIM Steering Wheel")) +  # Update x-axis labels
    scale_x_discrete(labels = c("B", "P–G",  "P–HaP", "P–HeP", "P–WW", "W–G", "W–HaP", "W–HeP", "W–WW")) +
    labs(
      x = "Technique",  # Update x-axis title
      y = "Average SUS Score"  # Update y-axis title
    ) +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = textsize),  # Center x-axis labels
      axis.text.y = element_text(size = textsize),  # Added size for y-axis tick marks
      axis.title = element_text(size = titlesize),
      axis.title.x = element_blank(),
      legend.position = "none")

  significance_data <- data.frame(
    x_start = numeric(),
    x_end = numeric(),
    y_start = numeric(),
    y_end = numeric(),
    label = character()
  )

  return(box)
}



# Define significance whiskers programmatically
# 1: Baseline
# 2: Portal Gallery
# 3: Portal Palette Hand
# 4: Portal Palette Head
# 5: Portal Steering Wheel
# 6: WIM Gallery
# 7: WIM Palette Hand
# 8: WIM Palette Head
# 9: WIM Steering Wheel
significance_data_sus <- data.frame(
    x_start = numeric(),
    x_end = numeric(),
    y_start = numeric(),
    y_end = numeric(),
    label = character()
  )
w_h = 0.0
y_space = 7.5
y_start = 105
significance_data_sus <- significance_data_sus %>%
  # Baseline / Portal Palette Head
  add_row(x_start = 1, x_end = 4, y_start = y_start, y_end = y_start-w_h, label = "***") %>%
  # Basline / WIM Palette Head
  add_row(x_start = 1, x_end = 8, y_start = y_start+y_space*1, y_end = y_start-w_h, label = "**") %>%
  # Portal Gallery / Portal Palette Head
  add_row(x_start = 2, x_end = 4, y_start = y_start+y_space*2, y_end = y_start-w_h, label = "*") %>%
  # Portal Palette Hand / Portal Palette Head
  add_row(x_start = 3, x_end = 4, y_start = y_start+y_space*3, y_end = y_start-w_h, label = "***") %>%
  # Portal Palette Head / Portal Steering Wheel
  add_row(x_start = 4, x_end = 5, y_start = y_start+y_space*4, y_end = y_start-w_h, label = "***") %>%
  # Portal Palette Head / WIM Gallery
  add_row(x_start = 4, x_end = 6, y_start = y_start+y_space*5, y_end = y_start-w_h, label = "**") %>%
  # Portal Palette Head / WIM Palette Hand
  add_row(x_start = 4, x_end = 7, y_start = y_start+y_space*6, y_end = y_start-w_h, label = "***") %>%
  # Portal Palette Head / WIM Palette Head
  add_row(x_start = 4, x_end = 8, y_start = y_start+y_space*7, y_end = y_start-w_h, label = "*") %>%
  # Portal Palette Head / WIM Steering Wheel
  add_row(x_start = 4, x_end = 9, y_start = y_start+y_space*8, y_end = y_start-w_h, label = "***") %>%
  # WIM Palette Hand / WIM Palette Head
  add_row(x_start = 7, x_end = 8, y_start = y_start+y_space*3, y_end = y_start-w_h, label = "*")


# Create the box plot for search time
sus_plot = plot_sus(df_org_subjective)
sus_plot = add_whiskers_periods(sus_plot, significance_data_sus, subj_ast_spacing + 0.85, 0.5)
sus_plot
ggsave(file.path(save_base_path, "box_sus_technique.pdf"), plot = susplot, width = 5, height = 10, dpi = 300)
```

Continuity Questions
```{r}
df = df_nrml_subjective
# check distribution of the data
hist(df$cont_avg2, breaks = 20, main = "Histogram of UEQ Hedonic Scores", xlab = "UEQ Hedonic Score", ylab = "Frequency")

# density plot
plot(density(df$cont_avg, na.rm = TRUE), main = "Density Plot of sus Scores", xlab = "UEQ Hedonic Score", ylab = "Density")

shapiro.test(df$cont_avg) # Shapiro-Wilk normality test
qqnorm(df$cont_avg) # Q-Q plot
qqline(df$cont_avg, col = "red") # Q-Q line

cont_gauss = lmerTest::lmer(cont_avg ~ Interface_Choice + (1 | PID),
                 data = df)


# Fit a Beta GLMM
model <- glmmTMB(cont_avg ~ Interface_Choice + (1 | PID),
                 data = df_nrml_subjective,
                 family = beta_family(link = "logit"))

sus_gaussian = glmer(cont_avg ~ Interface_Choice + (1 | PID),
                 data = df,
                 family = gaussian(link = "log"),
                 control = glm_ctrl)

sus_gaussian2 = glmer(cont_avg ~ Interface_Choice + VR_Exp + (1 | PID),
                 data = df,
                 family = gaussian(link = "log"),
                 control = glm_ctrl)

Cand.mods = list(
          "sus_gaussian" = sus_gaussian,
          "sus_gaussian2" = sus_gaussian2
           )

# glm_1_4 is ranked best for AICc and BIC
# including trial and technique preview as random slope leads to convergence issues

AICcmodavg::aictab(cand.set = Cand.mods)
AICcmodavg::bictab(cand.set = Cand.mods)

# Check for normality of residuals

glm = cont_gauss
performance::check_model(glm)
shapiro.test(residuals(glm)) # Shapiro-Wilk normality test
performance::check_collinearity(glm)
performance::check_singularity(glm)
performance::check_outliers(glm)
performance::r2(glm)
simulationOutput <- simulateResiduals(fittedModel = glm)
testDispersion(simulationOutput)
car::Anova(glm)
summary(glm)
# Perform pairwise comparisons with Tukey HSD correction
emm_cont <- emmeans::emmeans(glm, specs = pairwise ~ Interface_Choice, type = "response", adjust = "tukey")
emm_cont

# compute average of first two continuity questions
cont_cols <- grep("^Cont_\\d+_1$", names(df_org_subjective), value = TRUE)
print(cont_cols)
# compute average of just the first two continuity questions
df_org_subjective$cont_avg = rowMeans(df_org_subjective[cont_cols], na.rm = TRUE)

plot_cont <- function(data) {
  box = ggplot(data, aes(x = Interface_Choice, y = cont_avg, fill = Interface_Choice)) +
    geom_boxplot() +
    scale_fill_brewer(palette = "Set3") +  # colorblind-safe palette
    scale_y_continuous(breaks = seq(0, 7, by = 1),  # Add ticks for every 5 units, including 40
                       minor_breaks = seq(0, 7, by = 0.5),
                       limits = c(1, 10.25)) +  # Label all ticks
    # scale_x_discrete(labels = c("Baseline", "Portal Gallery",  "Portal Palette Hand", "Portal Palette Head", "Portal Steering Wheel", "WIM Gallery", "WIM Palette Hand", "WIM Palette Head", "WIM Steering Wheel")) +  # Update x-axis labels
    scale_x_discrete(labels = c("B", "P–G",  "P–HaP", "P–HeP", "P–WW", "W–G", "W–HaP", "W–HeP", "W–WW")) +
    labs(
      x = "Interaction Metaphor",  # Update x-axis title
      y = "Average Continuity Score"  # Update y-axis title
    ) +
    theme(
      axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = textsize),  # Center x-axis labels
      axis.text.y = element_text(size = textsize),  # Added size for y-axis tick marks
      axis.title = element_text(size = titlesize),
      axis.title.x = element_blank(),
      legend.position = "none")
  
  return(box)
}

# Define significance whiskers programmatically
# 1: Baseline
# 2: Portal Gallery
# 3: Portal Palette Hand
# 4: Portal Palette Head
# 5: Portal Steering Wheel
# 6: WIM Gallery
# 7: WIM Palette Hand
# 8: WIM Palette Head
# 9: WIM Steering Wheel
w_h = 0.0 
cont_y_start = 7.5
cont_y_space = 0.5
significance_data_cont <- data.frame(
    x_start = numeric(),
    x_end = numeric(),
    y_start = numeric(),
    y_end = numeric(),
    label = character()
) %>%
  # Baseline / Portal Gallery
  add_row(x_start = 1, x_end = 2, y_start = cont_y_start, y_end = y_start-w_h, label = "**") %>%
  # Baseline / Portal Palette Hand
  add_row(x_start = 1, x_end = 3, y_start = cont_y_start+cont_y_space*1, y_end = y_start-w_h, label = "***") %>%
  # Baseline / Portal Steering Wheel
  add_row(x_start = 1, x_end = 5, y_start = cont_y_start+cont_y_space*2, y_end = y_start-w_h, label = "***") %>%
  # Baseline / WIM Gallery
  add_row(x_start = 1, x_end = 6, y_start = cont_y_start+cont_y_space*3, y_end = y_start-w_h, label = "*") %>%
  # Baseline / WIM Palette Hand
  add_row(x_start = 1, x_end = 7, y_start = cont_y_start+cont_y_space*4, y_end = y_start-w_h, label = "***") %>%
  # Baseline / WIM Steering Wheel
  add_row(x_start = 1, x_end = 9, y_start = cont_y_start+cont_y_space*5, y_end = y_start-w_h, label = "***")



# Create the box plot for search time
cont_plot = plot_cont(df_org_subjective)
cont_plot = add_whiskers_periods(cont_plot, significance_data_cont, subj_ast_spacing, 0.5)
cont_plot
ggsave(file.path(save_base_path, "box_sus_technique.pdf"), plot = susplot, width = 5, height = 10, dpi = 300)
```

```{r}

library(patchwork)


sus_plot = plot_sus(df_org_subjective)
sus_plot = add_whiskers_periods(sus_plot, significance_data_sus, subj_ast_spacing + 0.85, 0.5)
sus_plot
cont_plot = plot_cont(df_org_subjective)
cont_plot = add_whiskers_periods(cont_plot, significance_data_cont, subj_ast_spacing, 0.5)
tlx_plot = plot_tlx(df_org_subjective)
tlx_plot = add_whiskers_periods(tlx_plot, significance_data_tlx, subj_ast_spacing)
ueq_plot = plot_ueq(df_org_subjective)
ueq_plot = add_whiskers_periods(ueq_plot, significance_data_ueq, subj_ast_spacing)

margin = 20

ueq_plot = ueq_plot + theme(plot.margin = margin(0, margin, 0, margin))
tlx_plot = tlx_plot + theme(plot.margin = margin(0, margin, 0, margin))
sus_plot = sus_plot + theme(plot.margin = margin(0, margin, 0, margin))
cont_plot = cont_plot + theme(plot.margin = margin(0, margin, 0, margin))

# subjective_plot = (ueq_plot | cont_plot) / (tlx_plot | sus_plot)

subjective_plot = (ueq_plot | cont_plot | tlx_plot | sus_plot)

subjective_plot

ggsave(file.path(save_base_path, "subjective_results_3.pdf"), plot = subjective_plot, width = 20, height = 6, dpi = 300)
```